import type { ArgTypes } from 'storybook/internal/csf';

interface SchemaProp {
  type: string;
  displayName?: string;
  description?: string;
  default?: any;
  min?: number;
  max?: number;
  step?: number;
  unit?: string;
  properties?: Record<string, SchemaProp>;
}

interface Schema {
  type: string;
  displayName: string;
  description?: string;
  category?: string;
  props: Record<string, SchemaProp>;
}

type ControlConfig =
  | { type: 'color'; presetColors?: string[] }
  | { type: 'range'; min?: number; max?: number; step?: number }
  | { type: 'number'; min?: number; max?: number; step?: number }
  | { type: 'boolean' }
  | { type: 'text' }
  | { type: 'object' };

function propTypeToControl(prop: SchemaProp): ControlConfig {
  switch (prop.type) {
    case 'color':
      return { type: 'color', presetColors: ['#ffffff', '#000000', '#6366f1', '#22c55e', '#ef4444'] };
    case 'range':
      return { type: 'range', min: prop.min ?? 0, max: prop.max ?? 100, step: prop.step ?? 1 };
    case 'number':
      return { type: 'number', min: prop.min, max: prop.max, step: prop.step ?? 1 };
    case 'boolean':
      return { type: 'boolean' };
    case 'textarea':
    case 'string':
      return { type: 'text' };
    case 'image':
    case 'array':
    case 'object':
      return { type: 'object' };
    default:
      return { type: 'text' };
  }
}

export function schemaToArgTypes(schema: Schema): ArgTypes {
  const argTypes: ArgTypes = {};

  for (const [propName, prop] of Object.entries(schema.props)) {
    argTypes[propName] = {
      name: prop.displayName || propName,
      description: prop.description,
      control: propTypeToControl(prop),
      table: {
        category: prop.type === 'object' || prop.type === 'array' ? 'Grouped' : 'Props',
        type: { summary: prop.type },
        defaultValue: { summary: typeof prop.default === 'object' ? JSON.stringify(prop.default) : String(prop.default ?? '') }
      }
    };
  }

  return argTypes;
}

export function schemaToDefaultArgs(schema: Schema): Record<string, any> {
  const args: Record<string, any> = {};

  for (const [propName, prop] of Object.entries(schema.props)) {
    if (prop.default !== undefined) {
      args[propName] = prop.default;
    } else if (prop.type === 'object' && prop.properties) {
      const nestedArgs: Record<string, any> = {};
      for (const [nestedName, nestedProp] of Object.entries(prop.properties)) {
        if (nestedProp.default !== undefined) {
          nestedArgs[nestedName] = nestedProp.default;
        }
      }
      if (Object.keys(nestedArgs).length > 0) {
        args[propName] = nestedArgs;
      }
    }
  }

  return args;
}
